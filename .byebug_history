exit
c.normal_cost_of_living_rank
c
    return if score > next_score || score < previous_score
previous_score = scores[i-1]
next_score = scores[i+1]
c
score =c
score
c
numbers.delete(numbers.max)
number
c
exit
numbers.reject{|n| n== this}.reduce(:*)
numbers.reject{|n| n== this}.reduce(0, :*)
numbers.reject{|n| n== this}
this
c
i
c
numbers
c
exit
products
c
profit > max_profit
profit = later_transactions.max - this_transaction
later_transactions.max - this_transaction
later_transactions = monies.select { |i| monies.index(i) > monies.index(this_transaction) }
c
later_transactions.max - this_transaction
later_transactions = monies.select { |i| monies.index(i) > monies.index(this_transaction) }
c
later_transactions.max - this_transaction
later_transactions = monies.select { |i| monies.index(i) > monies.index(this_transaction) }
c
later_transactions.max - this_transaction
later_transactions = monies.select { |i| monies.index(i) > monies.index(this_transaction) }
later_transactions.max - this_transaction
c
later_transactions.max - this_transaction
later_transactions = monies.select { |i| monies.index(i) > monies.index(this_transaction) }
c
max_profit
c
max_profit
c
max_profit
c
max_profit
c
max_profit = profit
profit > max_profit
profit > max_prifit
this_transaction
later_transactions.max
profit = later_transactions.max - this_transaction
later_transactions = monies.select { |i| monies.index(i) > monies.index(this_transaction) }
c
monies.select { |i| monies.index(i) > monies.index(this_transaction) }
exit
monies.index(i)
monies
later_transactions = monies.select { |i| monies.index(i) > i }
exit
c
cc
c
ranks_for_attr(attr)
c
exit
ranks_for_attr(attr)
c
exit
Country.pluck(:id, attr.to_sym)
attr
ranks
c
exit
c
NormalizeData.new("country").normalize_category_ranks(attr, 1, 100)
@normalized_cost_of_living_rank_column
instance_variable_set("@normalized_#{attr}_column", NormalizeData.new("country").normalize_category_ranks(attr, 1, 100))
attr
exit
c
cc
exit
find_by name: "life_satisfaction_rank"
where name: "life_satisfaction_rank"
where name: "life_satisfaction_rank
exit
c
country.ranks.create(name: "life_satisfaction_rank", score: rank, order: "asc")
exit
c
country.ranks.build(name: "life_satisfaction_rank", score: rank, order: "asc")
country
c
Country.pluck(:id, attr.to_sym)
attr
c
ranks
c
Country.pluck(:cost_of_living_rank)
Country.pluck(attr.to_sym)
attr.to_sym
Country.pluck(:id, attr.to_sym)
attr
c
ranks
c
Country.pluck(:id, attr.to_sym)
c
attr
Country.pluck(:id, attr.to_sym)
Country.pluck(:id, attr.to_sym).reject{ |r| r[1] == nil }
c
ranks
ranks.map { |id, n| [id, ( min + (n - current_min) * (max - min) / (current_max - current_min) ).round] }
c
Country.pluck(:id, attr.to_sym).reject{ |r| r[1] == nil }
c
@table.titleize.constantize.column_names
@table.titleize.constantize.columns
Country
@table.constantize.columns
@table.titlize.columns
@table.titalize.columns
@table.columns
@table
c
Country.pluck(attr.to_sym).reject{ |r| r == nil }.max
Country.pluck(attr.to_sym).reject{ |r| r == nil }.min
Country.pluck(attr.to_sym).reject{ |r| r == nil }
Country.pluck(attr.to_sym).reject{ |r| r[1] == nil }
Country.pluck(attr.to_sym)
Country.min_value(attr)
initial_order == "asc"
c
reload!
reload
ranks[1]
ranks
c
ranks.reject{|r| r[1] == nil}
ranks
exit
c
rows
c
rows
c
driver.find_elements(:css, ".ResponseGrid #rgReport_ctl00 tbody tr")
driver.find_elements(:css, ".ResponseGrid #rgReport_ctl00 tbody tr)
driver.find_elements(:css, ".ResponseGrid #rgReport_ctl00 tbody tr
rows
c
rows
c
exit
c
driver.find_elements(:css, "#rgReport_ctl00 tbody tr")
rows
c
params[:subject]
c
exit
rows.first.find_element(:css, "td:nth-of-type(2)").text
rows.first {|row| row.find_element(:css, "td:nth-of-type(2)").text}
rows.each {|row| row.find_element(:css, "td:nth-of-type(2)").text}
rows.each {|row| row.find_element(:css, "td:nth-of-type(2)")}
rows = driver.find_elements(:css, "#t2 tbody tr")
exit
rows.count
rows
rows.each {|row| row.find_element(:css, "td")}
rows.each {|row| row.find_element(:css, "td:nth-of-type(1)")}
rows.each {|row| row.find_element(:css, "td:nth-of-type(2)")}
    rows = driver.find_elements(:css, "#t2 tr")
c
rows = driver.find_elements(:css, "#t2 tr")
exit
rows = driver.find_elements(:css, "#t2 tr")
rows.each { |row| row.find_element(:css, "td:nth-of-type(1)") }
rows = driver.find_element(:css, "#t2 tr")
c
rank
name
c
rank
name
exit
entry.find_element(:css, 'div.row').text
entry.find_element(:css, '.row').text
entry.find_element(:css, '.span3').text
entry.find_element(:css, '.span3 .minichart').text
entry.find_element(:css, '.span3 .minichart .countryRank').text
entry.find_element(:css, '.span3 .minichart .countryRank')
entry.find_element(:css, '.span3 .minichart')
entry.find_element(:css, '.span3')
rank
name
exit
rank
exit
name
rank
exit
name
nam
rank
exit
name
exit
driver.find_element(:class => "countryRank").text.downcase.start_with? "rank"
driver.find_element(:class => "countryRank").text
driver.find_element :class => "minichart"
driver.title
